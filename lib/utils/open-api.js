"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateOpenApiFile = exports.addMetadatas = void 0;
const fs = require("fs");
const path = require("path");
function extractPathParameters(url) {
    // Regular expression to match {something}
    const regex = /\{[^}]+\}/g;
    // Find all matches
    const matches = url.match(regex);
    // If no matches are found, return an empty array
    if (!matches) {
        return [];
    }
    // Remove the curly braces from each match
    const parameters = matches.map((match) => match.slice(1, -1));
    return parameters;
}
const addMetadatas = (node, schemaProps) => {
    node.addMetadata("requestBodySchema", schemaProps?.requestBodySchema);
    node.addMetadata("responseSchema", schemaProps?.responseSchema);
    node.addMetadata("queryStringSchema", schemaProps?.queryStringSchema);
    node.addMetadata("responseTypeIsArray", schemaProps?.responseTypeIsArray);
};
exports.addMetadatas = addMetadatas;
const generateOpenApiSpec = (url, method, schemaProps) => {
    let requestBodySchema = schemaProps.requestBodySchema;
    const pathParametersSchema = extractPathParameters(url).map((param) => ({
        name: param,
        in: "path",
        description: `URL param for ${param}`,
        required: true,
        schema: {
            type: "string",
        },
    }));
    let responseSchemaRef = schemaProps.responseSchema;
    let responseSchema;
    if (schemaProps.responseTypeIsArray) {
        responseSchema = {
            type: "array",
            items: {
                $ref: `#/components/schemas/${responseSchemaRef}`,
            },
        };
    }
    else {
        responseSchema = {
            $ref: `#/components/schemas/${responseSchemaRef}`,
        };
    }
    const openApiSpec = {
        [url]: {
            [method.toLowerCase()]: {
                ...(requestBodySchema &&
                    method.toLowerCase() != "get" && {
                    requestBody: {
                        content: {
                            "application/json": {
                                schema: { $ref: `#/components/schemas/${requestBodySchema}` },
                            },
                        },
                    },
                }),
                ...(pathParametersSchema && {
                    parameters: pathParametersSchema,
                }),
                // ...(queryStringParametersSchema && {
                //   parameters: [
                //     {
                //       in: "query",
                //       schema: {
                //         $ref: `#/components/schemas/${queryStringParametersSchema}`,
                //       },
                //     },
                //   ],
                // }),
                responses: {
                    200: {
                        description: "Successful response",
                        content: {
                            "application/json": {
                                schema: responseSchema,
                            },
                        },
                    },
                },
            },
        },
    };
    return openApiSpec;
};
/**
 * Generate OpenAPI file
 * Pass the API Gateway RestAPI and the schemas to generate the OpenAPI file
 * @param api - API Gateway RestAPI
 * @param schemas - Schemas to be used in the OpenAPI file, usually the same as the ones used in the API ... this should be the same contract as the OpenAPI-ts SchemaObject
 * @returns void
 */
function generateOpenApiFile(api, schemas) {
    // @ts-ignore
    const apiPaths = api.methods.reduce((acc, method) => {
        if (method.httpMethod === "OPTIONS") {
            return acc;
        }
        const normalizedPath = method.node.scope.path.replace("/api", "");
        const requestBodySchema = method.node.metadata.find((metadata) => metadata.type === "requestBodySchema");
        const responseSchema = method.node.metadata.find((metadata) => metadata.type === "responseSchema");
        const queryStringSchema = method.node.metadata.find((metadata) => metadata.type === "queryStringSchema");
        const responseTypeIsArray = method.node.metadata.find((metadata) => metadata.type === "responseTypeIsArray");
        acc.push({
            path: normalizedPath,
            method: method.httpMethod,
            schemaProps: {
                requestBodySchema: requestBodySchema?.data,
                responseSchema: responseSchema?.data,
                queryStringSchema: queryStringSchema?.data,
                responseTypeIsArray: responseTypeIsArray?.data,
            },
        });
        return acc;
    }, []);
    const paths = [];
    for (const element of apiPaths) {
        const apiPath = element;
        const path = generateOpenApiSpec(apiPath.path, apiPath.method, apiPath.schemaProps);
        paths.push(path);
    }
    const openApiSpec = {
        openapi: "3.0.0",
        info: {
            title: "API",
            version: "1.0.0",
        },
        paths: mergeObjects(...paths),
        components: {
            schemas,
        },
    };
    fs.writeFileSync(path.resolve(__dirname, "../../openapi.json"), JSON.stringify(openApiSpec, null, 2));
}
exports.generateOpenApiFile = generateOpenApiFile;
const isObject = (obj) => obj && typeof obj === "object";
const mergeObjects = (...objects) => {
    return objects.reduce((acc, obj) => {
        Object.keys(obj).forEach((key) => {
            const accValue = acc[key];
            const objValue = obj[key];
            if (Array.isArray(accValue) && Array.isArray(objValue)) {
                acc[key] = accValue.concat(...objValue);
            }
            else if (isObject(accValue) && isObject(objValue)) {
                acc[key] = mergeObjects(accValue, objValue);
            }
            else {
                acc[key] = objValue;
            }
        });
        return acc;
    }, {});
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3Blbi1hcGkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJvcGVuLWFwaS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFFQSx5QkFBeUI7QUFDekIsNkJBQTZCO0FBbUI3QixTQUFTLHFCQUFxQixDQUFDLEdBQVc7SUFDeEMsMENBQTBDO0lBQzFDLE1BQU0sS0FBSyxHQUFHLFlBQVksQ0FBQztJQUUzQixtQkFBbUI7SUFDbkIsTUFBTSxPQUFPLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUVqQyxpREFBaUQ7SUFDakQsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ2IsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDO0lBRUQsMENBQTBDO0lBQzFDLE1BQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUU5RCxPQUFPLFVBQVUsQ0FBQztBQUNwQixDQUFDO0FBRU0sTUFBTSxZQUFZLEdBQUcsQ0FBQyxJQUFVLEVBQUUsV0FBeUIsRUFBRSxFQUFFO0lBQ3BFLElBQUksQ0FBQyxXQUFXLENBQUMsbUJBQW1CLEVBQUUsV0FBVyxFQUFFLGlCQUFpQixDQUFDLENBQUM7SUFDdEUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxnQkFBZ0IsRUFBRSxXQUFXLEVBQUUsY0FBYyxDQUFDLENBQUM7SUFDaEUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxtQkFBbUIsRUFBRSxXQUFXLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztJQUN0RSxJQUFJLENBQUMsV0FBVyxDQUFDLHFCQUFxQixFQUFFLFdBQVcsRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO0FBQzVFLENBQUMsQ0FBQztBQUxXLFFBQUEsWUFBWSxnQkFLdkI7QUFFRixNQUFNLG1CQUFtQixHQUFHLENBQzFCLEdBQVcsRUFDWCxNQUFjLEVB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Q0FBQyxHQUFHLFlBQVksQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFDOUMsQ0FBQztpQkFBTSxDQUFDO2dCQUNOLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxRQUFRLENBQUM7WUFDdEIsQ0FBQztRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDVCxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJUmVzdEFwaSB9IGZyb20gXCJhd3MtY2RrLWxpYi9hd3MtYXBpZ2F0ZXdheVwiO1xuaW1wb3J0IHsgSHR0cE1ldGhvZHMgfSBmcm9tIFwiYXdzLWNkay1saWIvYXdzLXMzXCI7XG5pbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnNcIjtcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIjtcbmltcG9ydCB0eXBlIHsgU2NoZW1hT2JqZWN0IH0gZnJvbSBcIm9wZW5hcGkzLXRzL2Rpc3QvbW9kZWwvb3BlbmFwaTMwXCI7XG5pbXBvcnQgeyBOb2RlIH0gZnJvbSBcImNvbnN0cnVjdHNcIjtcblxudHlwZSBQYXRoID0ge1xuICBtZXRob2Q6IEh0dHBNZXRob2RzO1xuICBwYXRoOiBzdHJpbmc7XG4gIHNjaGVtYVByb3BzOiBTY2hlbWFQcm9wcztcbn07XG5cbmV4cG9ydCB0eXBlIFNjaGVtYVBhcmFtcyA9IFJlY29yZDxzdHJpbmcsIFNjaGVtYU9iamVjdD47XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2NoZW1hUHJvcHMge1xuICByZXNwb25zZVNjaGVtYT86IHN0cmluZztcbiAgcmVzcG9uc2VUeXBlSXNBcnJheT86IGJvb2xlYW47XG4gIHF1ZXJ5U3RyaW5nU2NoZW1hPzogc3RyaW5nO1xuICByZXF1ZXN0Qm9keVNjaGVtYT86IHN0cmluZztcbn1cblxuZnVuY3Rpb24gZXh0cmFjdFBhdGhQYXJhbWV0ZXJzKHVybDogc3RyaW5nKTogc3RyaW5nW10ge1xuICAvLyBSZWd1bGFyIGV4cHJlc3Npb24gdG8gbWF0Y2gge3NvbWV0aGluZ31cbiAgY29uc3QgcmVnZXggPSAvXFx7W159XStcXH0vZztcblxuICAvLyBGaW5kIGFsbCBtYXRjaGVzXG4gIGNvbnN0IG1hdGNoZXMgPSB1cmwubWF0Y2gocmVnZXgpO1xuXG4gIC8vIElmIG5vIG1hdGNoZXMgYXJlIGZvdW5kLCByZXR1cm4gYW4gZW1wdHkgYXJyYXlcbiAgaWYgKCFtYXRjaGVzKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLy8gUmVtb3ZlIHRoZSBjdXJseSBicmFjZXMgZnJvbSBlYWNoIG1hdGNoXG4gIGNvbnN0IHBhcmFtZXRlcnMgPSBtYXRjaGVzLm1hcCgobWF0Y2gpID0+IG1hdGNoLnNsaWNlKDEsIC0xKSk7XG5cbiAgcmV0dXJuIHBhcmFtZXRlcnM7XG59XG5cbmV4cG9ydCBjb25zdCBhZGRNZXRhZGF0YXMgPSAobm9kZTogTm9kZSwgc2NoZW1hUHJvcHM/OiBTY2hlbWFQcm9wcykgPT4ge1xuICBub2RlLmFkZE1ldGFkYXRhKFwicmVxdWVzdEJvZHlTY2hlbWFcIiwgc2NoZW1hUHJvcHM/LnJlcXVlc3RCb2R5U2NoZW1hKTtcbiAgbm9kZS5hZGRNZXRhZGF0YShcInJlc3BvbnNlU2NoZW1hXCIsIHNjaGVtYVByb3BzPy5yZXNwb25zZVNjaGVtYSk7XG4gIG5vZGUuYWRkTWV0YWRhdGEoXCJxdWVyeVN0cmluZ1NjaGVtYVwiLCBzY2hlbWFQcm9wcz8ucXVlcnlTdHJpbmdTY2hlbWEpO1xuICBub2RlLmFkZE1ldGFkYXRhKFwicmVzcG9uc2VUeXBlSXNBcnJheVwiLCBzY2hlbWFQcm9wcz8ucmVzcG9uc2VUeXBlSXNBcnJheSk7XG59O1xuXG5jb25zdCBnZW5lcmF0ZU9wZW5BcGlTcGVjID0gKFxuICB1cmw6IHN0cmluZyxcbiAgbWV0aG9kOiBzdHJpbmcsXG4gIHNjaGVtYVByb3BzOiBTY2hlbWFQcm9wc1xuKSA9PiB7XG4gIGxldCByZXF1ZXN0Qm9keVNjaGVtYTogYW55ID0gc2NoZW1hUHJvcHMucmVxdWVzdEJvZHlTY2hlbWE7XG5cbiAgY29uc3QgcGF0aFBhcmFtZXRlcnNTY2hlbWEgPSBleHRyYWN0UGF0aFBhcmFtZXRlcnModXJsKS5tYXAoKHBhcmFtKSA9PiAoe1xuICAgIG5hbWU6IHBhcmFtLFxuICAgIGluOiBcInBhdGhcIixcbiAgICBkZXNjcmlwdGlvbjogYFVSTCBwYXJhbSBmb3IgJHtwYXJhbX1gLFxuICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgIHNjaGVtYToge1xuICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICB9LFxuICB9KSk7XG5cbiAgbGV0IHJlc3BvbnNlU2NoZW1hUmVmOiBhbnkgPSBzY2hlbWFQcm9wcy5yZXNwb25zZVNjaGVtYTtcblxuICBsZXQgcmVzcG9uc2VTY2hlbWE6IGFueTtcbiAgaWYgKHNjaGVtYVByb3BzLnJlc3BvbnNlVHlwZUlzQXJyYXkpIHtcbiAgICByZXNwb25zZVNjaGVtYSA9IHtcbiAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgIGl0ZW1zOiB7XG4gICAgICAgICRyZWY6IGAjL2NvbXBvbmVudHMvc2NoZW1hcy8ke3Jlc3BvbnNlU2NoZW1hUmVmfWAsXG4gICAgICB9LFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmVzcG9uc2VTY2hlbWEgPSB7XG4gICAgICAkcmVmOiBgIy9jb21wb25lbnRzL3NjaGVtYXMvJHtyZXNwb25zZVNjaGVtYVJlZn1gLFxuICAgIH07XG4gIH1cblxuICBjb25zdCBvcGVuQXBpU3BlYyA9IHtcbiAgICBbdXJsXToge1xuICAgICAgW21ldGhvZC50b0xvd2VyQ2FzZSgpXToge1xuICAgICAgICAuLi4ocmVxdWVzdEJvZHlTY2hlbWEgJiZcbiAgICAgICAgICBtZXRob2QudG9Mb3dlckNhc2UoKSAhPSBcImdldFwiICYmIHtcbiAgICAgICAgICAgIHJlcXVlc3RCb2R5OiB7XG4gICAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgICBcImFwcGxpY2F0aW9uL2pzb25cIjoge1xuICAgICAgICAgICAgICAgICAgc2NoZW1hOiB7ICRyZWY6IGAjL2NvbXBvbmVudHMvc2NoZW1hcy8ke3JlcXVlc3RCb2R5U2NoZW1hfWAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgLi4uKHBhdGhQYXJhbWV0ZXJzU2NoZW1hICYmIHtcbiAgICAgICAgICBwYXJhbWV0ZXJzOiBwYXRoUGFyYW1ldGVyc1NjaGVtYSxcbiAgICAgICAgfSksXG4gICAgICAgIC8vIC4uLihxdWVyeVN0cmluZ1BhcmFtZXRlcnNTY2hlbWEgJiYge1xuICAgICAgICAvLyAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgLy8gICAgIHtcbiAgICAgICAgLy8gICAgICAgaW46IFwicXVlcnlcIixcbiAgICAgICAgLy8gICAgICAgc2NoZW1hOiB7XG4gICAgICAgIC8vICAgICAgICAgJHJlZjogYCMvY29tcG9uZW50cy9zY2hlbWFzLyR7cXVlcnlTdHJpbmdQYXJhbWV0ZXJzU2NoZW1hfWAsXG4gICAgICAgIC8vICAgICAgIH0sXG4gICAgICAgIC8vICAgICB9LFxuICAgICAgICAvLyAgIF0sXG4gICAgICAgIC8vIH0pLFxuICAgICAgICByZXNwb25zZXM6IHtcbiAgICAgICAgICAyMDA6IHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlN1Y2Nlc3NmdWwgcmVzcG9uc2VcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgXCJhcHBsaWNhdGlvbi9qc29uXCI6IHtcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHJlc3BvbnNlU2NoZW1hLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICB9O1xuXG4gIHJldHVybiBvcGVuQXBpU3BlYztcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgT3BlbkFQSSBmaWxlXG4gKiBQYXNzIHRoZSBBUEkgR2F0ZXdheSBSZXN0QVBJIGFuZCB0aGUgc2NoZW1hcyB0byBnZW5lcmF0ZSB0aGUgT3BlbkFQSSBmaWxlXG4gKiBAcGFyYW0gYXBpIC0gQVBJIEdhdGV3YXkgUmVzdEFQSVxuICogQHBhcmFtIHNjaGVtYXMgLSBTY2hlbWFzIHRvIGJlIHVzZWQgaW4gdGhlIE9wZW5BUEkgZmlsZSwgdXN1YWxseSB0aGUgc2FtZSBhcyB0aGUgb25lcyB1c2VkIGluIHRoZSBBUEkgLi4uIHRoaXMgc2hvdWxkIGJlIHRoZSBzYW1lIGNvbnRyYWN0IGFzIHRoZSBPcGVuQVBJLXRzIFNjaGVtYU9iamVjdFxuICogQHJldHVybnMgdm9pZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVPcGVuQXBpRmlsZShcbiAgYXBpOiBJUmVzdEFwaSxcbiAgc2NoZW1hczogUmVjb3JkPHN0cmluZywgU2NoZW1hT2JqZWN0PlxuKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgY29uc3QgYXBpUGF0aHM6IFBhdGhbXSA9IGFwaS5tZXRob2RzLnJlZHVjZSgoYWNjOiBQYXRoW10sIG1ldGhvZCkgPT4ge1xuICAgIGlmIChtZXRob2QuaHR0cE1ldGhvZCA9PT0gXCJPUFRJT05TXCIpIHtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuXG4gICAgY29uc3Qgbm9ybWFsaXplZFBhdGggPSBtZXRob2Qubm9kZS5zY29wZS5wYXRoLnJlcGxhY2UoXCIvYXBpXCIsIFwiXCIpO1xuXG4gICAgY29uc3QgcmVxdWVzdEJvZHlTY2hlbWEgPSBtZXRob2Qubm9kZS5tZXRhZGF0YS5maW5kKFxuICAgICAgKG1ldGFkYXRhOiBhbnkpID0+IG1ldGFkYXRhLnR5cGUgPT09IFwicmVxdWVzdEJvZHlTY2hlbWFcIlxuICAgICk7XG5cbiAgICBjb25zdCByZXNwb25zZVNjaGVtYSA9IG1ldGhvZC5ub2RlLm1ldGFkYXRhLmZpbmQoXG4gICAgICAobWV0YWRhdGE6IGFueSkgPT4gbWV0YWRhdGEudHlwZSA9PT0gXCJyZXNwb25zZVNjaGVtYVwiXG4gICAgKTtcblxuICAgIGNvbnN0IHF1ZXJ5U3RyaW5nU2NoZW1hID0gbWV0aG9kLm5vZGUubWV0YWRhdGEuZmluZChcbiAgICAgIChtZXRhZGF0YTogYW55KSA9PiBtZXRhZGF0YS50eXBlID09PSBcInF1ZXJ5U3RyaW5nU2NoZW1hXCJcbiAgICApO1xuXG4gICAgY29uc3QgcmVzcG9uc2VUeXBlSXNBcnJheSA9IG1ldGhvZC5ub2RlLm1ldGFkYXRhLmZpbmQoXG4gICAgICAobWV0YWRhdGE6IGFueSkgPT4gbWV0YWRhdGEudHlwZSA9PT0gXCJyZXNwb25zZVR5cGVJc0FycmF5XCJcbiAgICApO1xuXG4gICAgYWNjLnB1c2goe1xuICAgICAgcGF0aDogbm9ybWFsaXplZFBhdGgsXG4gICAgICBtZXRob2Q6IG1ldGhvZC5odHRwTWV0aG9kLFxuICAgICAgc2NoZW1hUHJvcHM6IHtcbiAgICAgICAgcmVxdWVzdEJvZHlTY2hlbWE6IHJlcXVlc3RCb2R5U2NoZW1hPy5kYXRhLFxuICAgICAgICByZXNwb25zZVNjaGVtYTogcmVzcG9uc2VTY2hlbWE/LmRhdGEsXG4gICAgICAgIHF1ZXJ5U3RyaW5nU2NoZW1hOiBxdWVyeVN0cmluZ1NjaGVtYT8uZGF0YSxcbiAgICAgICAgcmVzcG9uc2VUeXBlSXNBcnJheTogcmVzcG9uc2VUeXBlSXNBcnJheT8uZGF0YSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgW10gYXMgUGF0aFtdKTtcblxuICBjb25zdCBwYXRocyA9IFtdO1xuICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgYXBpUGF0aHMpIHtcbiAgICBjb25zdCBhcGlQYXRoID0gZWxlbWVudDtcbiAgICBjb25zdCBwYXRoID0gZ2VuZXJhdGVPcGVuQXBpU3BlYyhcbiAgICAgIGFwaVBhdGgucGF0aCxcbiAgICAgIGFwaVBhdGgubWV0aG9kLFxuICAgICAgYXBpUGF0aC5zY2hlbWFQcm9wc1xuICAgICk7XG4gICAgcGF0aHMucHVzaChwYXRoKTtcbiAgfVxuXG4gIGNvbnN0IG9wZW5BcGlTcGVjID0ge1xuICAgIG9wZW5hcGk6IFwiMy4wLjBcIixcbiAgICBpbmZvOiB7XG4gICAgICB0aXRsZTogXCJBUElcIixcbiAgICAgIHZlcnNpb246IFwiMS4wLjBcIixcbiAgICB9LFxuICAgIHBhdGhzOiBtZXJnZU9iamVjdHMoLi4ucGF0aHMpLFxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIHNjaGVtYXMsXG4gICAgfSxcbiAgfTtcblxuICBmcy53cml0ZUZpbGVTeW5jKFxuICAgIHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsIFwiLi4vLi4vb3BlbmFwaS5qc29uXCIpLFxuICAgIEpTT04uc3RyaW5naWZ5KG9wZW5BcGlTcGVjLCBudWxsLCAyKVxuICApO1xufVxuXG5jb25zdCBpc09iamVjdCA9IChvYmo6IGFueSkgPT4gb2JqICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCI7XG5cbmNvbnN0IG1lcmdlT2JqZWN0cyA9IChcbiAgLi4ub2JqZWN0czogUmVjb3JkPHN0cmluZywgYW55PltdXG4pOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0+IHtcbiAgcmV0dXJuIG9iamVjdHMucmVkdWNlKChhY2MsIG9iaikgPT4ge1xuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCBhY2NWYWx1ZSA9IGFjY1trZXldO1xuICAgICAgY29uc3Qgb2JqVmFsdWUgPSBvYmpba2V5XTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYWNjVmFsdWUpICYmIEFycmF5LmlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgIGFjY1trZXldID0gYWNjVmFsdWUuY29uY2F0KC4uLm9ialZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoYWNjVmFsdWUpICYmIGlzT2JqZWN0KG9ialZhbHVlKSkge1xuICAgICAgICBhY2Nba2V5XSA9IG1lcmdlT2JqZWN0cyhhY2NWYWx1ZSwgb2JqVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWNjW2tleV0gPSBvYmpWYWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn07XG4iXX0=