"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getResourceByUrl = exports.generateRoute = void 0;
const aws_cdk_lib_1 = require("aws-cdk-lib");
const open_api_1 = require("./open-api");
function generateRoute({ scope, root, lambdaProps, url, method, authorizer, apiKeyRequired, schemaProps, }) {
    const currentRoute = (0, exports.getResourceByUrl)(root, url);
    const lambda = new aws_cdk_lib_1.aws_lambda_nodejs.NodejsFunction(scope, `${method}${url}`, {
        ...lambdaProps,
    });
    const lambdaIntegration = new aws_cdk_lib_1.aws_apigateway.LambdaIntegration(lambda);
    let methodsParams = {
        requestModels: {},
    };
    if (authorizer && !apiKeyRequired) {
        methodsParams = {
            authorizer,
        };
    }
    else if (apiKeyRequired) {
        methodsParams = {
            apiKeyRequired: true,
        };
    }
    const methodResource = currentRoute.addMethod(method, lambdaIntegration, methodsParams);
    (0, open_api_1.addMetadatas)(methodResource.node, schemaProps);
    // Generate OpenAPI spec
    let path;
    return {
        lambda,
        path,
    };
}
exports.generateRoute = generateRoute;
const resourceTree = {
    children: {},
    resource: {},
};
const getResourceByUrl = (rootResource, url) => {
    resourceTree.resource = rootResource;
    const segments = url.split("/");
    let currentNode = resourceTree;
    for (const segment of segments) {
        if (segment === "") {
            continue;
        }
        if (segment in currentNode.children) {
            currentNode = currentNode.children[segment];
        }
        else {
            const newResource = currentNode.resource.addResource(segment);
            const newNode = { children: {}, resource: newResource };
            currentNode.children[segment] = newNode;
            currentNode = newNode;
        }
    }
    return currentNode.resource;
};
exports.getResourceByUrl = getResourceByUrl;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91dGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9saWIvdXRpbHMvcm91dGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsNkNBSXFCO0FBRXJCLHlDQUF1RDtBQWF2RCxTQUFnQixhQUFhLENBQUMsRUFDNUIsS0FBSyxFQUNMLElBQUksRUFDSixXQUFXLEVBQ1gsR0FBRyxFQUNILE1BQU0sRUFDTixVQUFVLEVBQ1YsY0FBYyxFQUNkLFdBQVcsR0FDQTtJQUNYLE1BQU0sWUFBWSxHQUFHLElBQUEsd0JBQWdCLEVBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBRWpELE1BQU0sTUFBTSxHQUFHLElBQUksK0JBQVksQ0FBQyxjQUFjLENBQUMsS0FBSyxFQUFFLEdBQUcsTUFBTSxHQUFHLEdBQUcsRUFBRSxFQUFFO1FBQ3ZFLEdBQUcsV0FBVztLQUNmLENBQUMsQ0FBQztJQUVILE1BQU0saUJBQWlCLEdBQUcsSUFBSSw0QkFBVSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ25FLElBQUksYUFBYSxHQUE2QjtRQUM1QyxhQUFhLEVBQUUsRUFBRTtLQUNsQixDQUFDO0lBRUYsSUFBSSxVQUFVLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUNsQyxhQUFhLEdBQUc7WUFDZCxVQUFVO1NBQ1gsQ0FBQztJQUNKLENBQUM7U0FBTSxJQUFJLGNBQWMsRUFBRSxDQUFDO1FBQzFCLGFBQWEsR0FBRztZQUNkLGNBQWMsRUFBRSxJQUFJO1NBQ3JCLENBQUM7SUFDSixDQUFDO0lBRUQsTUFBTSxjQUFjLEdBQUcsWUFBWSxDQUFDLFNBQVMsQ0FDM0MsTUFBTSxFQUNOLGlCQUFpQixFQUNqQixhQUFhLENBQ2QsQ0FBQztJQUNGLElBQUEsdUJBQVksRUFBQyxjQUFjLENBQUMsSUFBSSxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBRS9DLHdCQUF3QjtJQUN4QixJQUFJLElBQXFFLENBQUM7SUFFMUUsT0FBTztRQUNMLE1BQU07UUFDTixJQUFJO0tBQ0wsQ0FBQztBQUNKLENBQUM7QUE3Q0Qsc0NBNkNDO0FBTUQsTUFBTSxZQUFZLEdBQVM7SUFDekIsUUFBUSxFQUFFLEVBQUU7SUFDWixRQUFRLEVBQUUsRUFBMEI7Q0FDckMsQ0FBQztBQUVLLE1BQU0sZ0JBQWdCLEdBQUcsQ0FDOUIsWUFBa0MsRUFDbEMsR0FBVyxFQUNXLEVBQUU7SUFDeEIsWUFBWSxDQUFDLFFBQVEsR0FBRyxZQUFZLENBQUM7SUFFckMsTUFBTSxRQUFRLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNoQyxJQUFJLFdBQVcsR0FBRyxZQUFZLENBQUM7SUFFL0IsS0FBSyxNQUFNLE9BQU8sSUFBSSxRQUFRLEVBQUUsQ0FBQztRQUMvQixJQUFJLE9BQU8sS0FBSyxFQUFFLEVBQUUsQ0FBQztZQUNuQixTQUFTO1FBQ1gsQ0FBQztRQUVELElBQUksT0FBTyxJQUFJLFdBQVcsQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUNwQyxXQUFXLEdBQUcsV0FBVyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM5QyxDQUFDO2FBQU0sQ0FBQztZQUNOLE1BQU0sV0FBVyxHQUFHLFdBQVcsQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQzlELE1BQU0sT0FBTyxHQUFHLEVBQUUsUUFBUSxFQUFFLEVBQUUsRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLENBQUM7WUFDeEQsV0FBVyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBRyxPQUFPLENBQUM7WUFDeEMsV0FBVyxHQUFHLE9BQU8sQ0FBQztRQUN4QixDQUFDO0lBQ0gsQ0FBQztJQUVELE9BQU8sV0FBVyxDQUFDLFFBQVEsQ0FBQztBQUM5QixDQUFDLENBQUM7QUF6QlcsUUFBQSxnQkFBZ0Isb0JBeUIzQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGF3c19hcGlnYXRld2F5IGFzIGFwaWdhdGV3YXksXG4gIGF3c19zMyBhcyBzMyxcbiAgYXdzX2xhbWJkYV9ub2RlanMgYXMgbGFtYmRhTm9kZUpzLFxufSBmcm9tIFwiYXdzLWNkay1saWJcIjtcbmltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gXCJjb25zdHJ1Y3RzXCI7XG5pbXBvcnQgeyBhZGRNZXRhZGF0YXMsIFNjaGVtYVByb3BzIH0gZnJvbSBcIi4vb3Blbi1hcGlcIjtcblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZVByb3BzIHtcbiAgc2NvcGU6IENvbnN0cnVjdDtcbiAgcm9vdDogYXBpZ2F0ZXdheS5JUmVzb3VyY2U7XG4gIHVybDogc3RyaW5nO1xuICBsYW1iZGFQcm9wczogbGFtYmRhTm9kZUpzLk5vZGVqc0Z1bmN0aW9uUHJvcHM7XG4gIG1ldGhvZDogczMuSHR0cE1ldGhvZHM7XG4gIGF1dGhvcml6ZXI/OiBhcGlnYXRld2F5LklBdXRob3JpemVyO1xuICBhcGlLZXlSZXF1aXJlZD86IGJvb2xlYW47XG4gIHNjaGVtYVByb3BzPzogU2NoZW1hUHJvcHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVJvdXRlKHtcbiAgc2NvcGUsXG4gIHJvb3QsXG4gIGxhbWJkYVByb3BzLFxuICB1cmwsXG4gIG1ldGhvZCxcbiAgYXV0aG9yaXplcixcbiAgYXBpS2V5UmVxdWlyZWQsXG4gIHNjaGVtYVByb3BzLFxufTogUm91dGVQcm9wcykge1xuICBjb25zdCBjdXJyZW50Um91dGUgPSBnZXRSZXNvdXJjZUJ5VXJsKHJvb3QsIHVybCk7XG5cbiAgY29uc3QgbGFtYmRhID0gbmV3IGxhbWJkYU5vZGVKcy5Ob2RlanNGdW5jdGlvbihzY29wZSwgYCR7bWV0aG9kfSR7dXJsfWAsIHtcbiAgICAuLi5sYW1iZGFQcm9wcyxcbiAgfSk7XG5cbiAgY29uc3QgbGFtYmRhSW50ZWdyYXRpb24gPSBuZXcgYXBpZ2F0ZXdheS5MYW1iZGFJbnRlZ3JhdGlvbihsYW1iZGEpO1xuICBsZXQgbWV0aG9kc1BhcmFtczogYXBpZ2F0ZXdheS5NZXRob2RPcHRpb25zID0ge1xuICAgIHJlcXVlc3RNb2RlbHM6IHt9LFxuICB9O1xuXG4gIGlmIChhdXRob3JpemVyICYmICFhcGlLZXlSZXF1aXJlZCkge1xuICAgIG1ldGhvZHNQYXJhbXMgPSB7XG4gICAgICBhdXRob3JpemVyLFxuICAgIH07XG4gIH0gZWxzZSBpZiAoYXBpS2V5UmVxdWlyZWQpIHtcbiAgICBtZXRob2RzUGFyYW1zID0ge1xuICAgICAgYXBpS2V5UmVxdWlyZWQ6IHRydWUsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IG1ldGhvZFJlc291cmNlID0gY3VycmVudFJvdXRlLmFkZE1ldGhvZChcbiAgICBtZXRob2QsXG4gICAgbGFtYmRhSW50ZWdyYXRpb24sXG4gICAgbWV0aG9kc1BhcmFtc1xuICApO1xuICBhZGRNZXRhZGF0YXMobWV0aG9kUmVzb3VyY2Uubm9kZSwgc2NoZW1hUHJvcHMpO1xuXG4gIC8vIEdlbmVyYXRlIE9wZW5BUEkgc3BlY1xuICBsZXQgcGF0aDogUmVjb3JkPHN0cmluZywgUmVjb3JkPHN0cmluZywgUmVjb3JkPHN0cmluZywgYW55Pj4+IHwgdW5kZWZpbmVkO1xuXG4gIHJldHVybiB7XG4gICAgbGFtYmRhLFxuICAgIHBhdGgsXG4gIH07XG59XG5cbnR5cGUgTm9kZSA9IHtcbiAgY2hpbGRyZW46IHsgW2tleTogc3RyaW5nXTogTm9kZSB9O1xuICByZXNvdXJjZTogYXBpZ2F0ZXdheS5JUmVzb3VyY2U7XG59O1xuY29uc3QgcmVzb3VyY2VUcmVlOiBOb2RlID0ge1xuICBjaGlsZHJlbjoge30sXG4gIHJlc291cmNlOiB7fSBhcyBhcGlnYXRld2F5LklSZXNvdXJjZSxcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRSZXNvdXJjZUJ5VXJsID0gKFxuICByb290UmVzb3VyY2U6IGFwaWdhdGV3YXkuSVJlc291cmNlLFxuICB1cmw6IHN0cmluZ1xuKTogYXBpZ2F0ZXdheS5JUmVzb3VyY2UgPT4ge1xuICByZXNvdXJjZVRyZWUucmVzb3VyY2UgPSByb290UmVzb3VyY2U7XG5cbiAgY29uc3Qgc2VnbWVudHMgPSB1cmwuc3BsaXQoXCIvXCIpO1xuICBsZXQgY3VycmVudE5vZGUgPSByZXNvdXJjZVRyZWU7XG5cbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgaWYgKHNlZ21lbnQgPT09IFwiXCIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzZWdtZW50IGluIGN1cnJlbnROb2RlLmNoaWxkcmVuKSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLmNoaWxkcmVuW3NlZ21lbnRdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuZXdSZXNvdXJjZSA9IGN1cnJlbnROb2RlLnJlc291cmNlLmFkZFJlc291cmNlKHNlZ21lbnQpO1xuICAgICAgY29uc3QgbmV3Tm9kZSA9IHsgY2hpbGRyZW46IHt9LCByZXNvdXJjZTogbmV3UmVzb3VyY2UgfTtcbiAgICAgIGN1cnJlbnROb2RlLmNoaWxkcmVuW3NlZ21lbnRdID0gbmV3Tm9kZTtcbiAgICAgIGN1cnJlbnROb2RlID0gbmV3Tm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3VycmVudE5vZGUucmVzb3VyY2U7XG59O1xuIl19